import * as assert from 'assert';
import { ReportGenerator } from '../../reportGenerator';
import { ValidationResult, EpubCheckResult } from '../../types/epubcheck';

/** Helper to create a minimal ValidationResult */
function makeResult(overrides: Partial<ValidationResult> = {}): ValidationResult {
    return {
        success: true,
        epubDir: '/path/to/my-book',
        ...overrides,
    };
}

/** Helper to create a minimal EpubCheckResult */
function makeCheckResult(overrides: Partial<EpubCheckResult> = {}): EpubCheckResult {
    return {
        checker: { name: 'epubcheck', checkerVersion: '5.1.0' },
        messages: [],
        ...overrides,
    };
}

describe('ReportGenerator', () => {

    // ---- generateMarkdown ----
    describe('generateMarkdown', () => {
        it('should include the report header', () => {
            const md = ReportGenerator.generateMarkdown([makeResult()]);
            assert.ok(md.includes('# EPUBCheck Validation Report'));
        });

        it('should include directory name as section heading', () => {
            const md = ReportGenerator.generateMarkdown([makeResult()]);
            assert.ok(md.includes('## my-book'));
        });

        it('should show error when result has error', () => {
            const md = ReportGenerator.generateMarkdown([
                makeResult({ error: 'Something went wrong' }),
            ]);
            assert.ok(md.includes('> **Error**: Something went wrong'));
        });

        it('should show message when no epubCheckResult', () => {
            const md = ReportGenerator.generateMarkdown([makeResult()]);
            assert.ok(md.includes('No validation results available.'));
        });

        it('should show no-errors message when messages array is empty', () => {
            const md = ReportGenerator.generateMarkdown([
                makeResult({ epubCheckResult: makeCheckResult() }),
            ]);
            assert.ok(md.includes('No errors or warnings found.'));
        });

        it('should escape pipe characters in messages', () => {
            const md = ReportGenerator.generateMarkdown([
                makeResult({
                    epubCheckResult: makeCheckResult({
                        messages: [{
                            ID: 'RSC-001',
                            severity: 'ERROR',
                            message: 'value|with|pipes',
                            additionalLocations: 0,
                            locations: [{ path: 'content.opf', line: 1, column: 1 }],
                        }],
                    }),
                }),
            ]);
            assert.ok(md.includes('value\\|with\\|pipes'));
        });

        it('should include publication info when available', () => {
            const md = ReportGenerator.generateMarkdown([
                makeResult({
                    epubCheckResult: makeCheckResult({
                        publication: {
                            title: 'My Book',
                            creator: ['Author A', 'Author B'],
                            language: 'en',
                            ePubVersion: '3.0',
                        },
                    }),
                }),
            ]);
            assert.ok(md.includes('| Title | My Book |'));
            assert.ok(md.includes('| Creator | Author A, Author B |'));
            assert.ok(md.includes('| Language | en |'));
            assert.ok(md.includes('| EPUB Version | 3.0 |'));
        });

        it('should count locations not messages in summary', () => {
            const md = ReportGenerator.generateMarkdown([
                makeResult({
                    epubCheckResult: makeCheckResult({
                        messages: [{
                            ID: 'RSC-001',
                            severity: 'ERROR',
                            message: 'error msg',
                            additionalLocations: 0,
                            locations: [
                                { path: 'a.xhtml', line: 1, column: 1 },
                                { path: 'b.xhtml', line: 2, column: 1 },
                                { path: 'c.xhtml', line: 3, column: 1 },
                            ],
                        }],
                    }),
                }),
            ]);
            assert.ok(md.includes('| Errors | 3 |'));
        });

        it('should include checker version (checkerVersion preferred)', () => {
            const md = ReportGenerator.generateMarkdown([
                makeResult({
                    epubCheckResult: makeCheckResult({
                        checker: { name: 'epubcheck', checkerVersion: '5.1.0', version: '4.0' },
                    }),
                }),
            ]);
            assert.ok(md.includes('*Generated by EPUBCheck v5.1.0*'));
        });

        it('should fall back to version when checkerVersion is absent', () => {
            const md = ReportGenerator.generateMarkdown([
                makeResult({
                    epubCheckResult: makeCheckResult({
                        checker: { name: 'epubcheck', version: '4.2.6' },
                    }),
                }),
            ]);
            assert.ok(md.includes('*Generated by EPUBCheck v4.2.6*'));
        });
    });

    // ---- generateText ----
    describe('generateText', () => {
        it('should include the report header', () => {
            const txt = ReportGenerator.generateText([makeResult()]);
            assert.ok(txt.includes('EPUBCheck Validation Report'));
        });

        it('should format messages as SEVERITY [ID] path:line - message', () => {
            const txt = ReportGenerator.generateText([
                makeResult({
                    epubCheckResult: makeCheckResult({
                        messages: [{
                            ID: 'RSC-005',
                            severity: 'ERROR',
                            message: 'Bad element',
                            additionalLocations: 0,
                            locations: [{ path: 'content.opf', line: 10, column: 5 }],
                        }],
                    }),
                }),
            ]);
            assert.ok(txt.includes('ERROR [RSC-005] content.opf:10 - Bad element'));
        });

        it('should show -:- for messages with no locations', () => {
            const txt = ReportGenerator.generateText([
                makeResult({
                    epubCheckResult: makeCheckResult({
                        messages: [{
                            ID: 'PKG-001',
                            severity: 'WARNING',
                            message: 'Package warning',
                            additionalLocations: 0,
                            locations: [],
                        }],
                    }),
                }),
            ]);
            assert.ok(txt.includes('WARNING [PKG-001] -:- - Package warning'));
        });

        it('should include suggestion when present', () => {
            const txt = ReportGenerator.generateText([
                makeResult({
                    epubCheckResult: makeCheckResult({
                        messages: [{
                            ID: 'RSC-005',
                            severity: 'ERROR',
                            message: 'Error',
                            suggestion: 'Try this fix',
                            additionalLocations: 0,
                            locations: [{ path: 'a.xhtml', line: 1, column: 1 }],
                        }],
                    }),
                }),
            ]);
            assert.ok(txt.includes('  Suggestion: Try this fix'));
        });

        it('should show ERROR for results with error field', () => {
            const txt = ReportGenerator.generateText([
                makeResult({ error: 'Jar not found' }),
            ]);
            assert.ok(txt.includes('ERROR: Jar not found'));
        });
    });

    // ---- generateJson ----
    describe('generateJson', () => {
        it('should produce valid JSON', () => {
            const json = ReportGenerator.generateJson([makeResult()]);
            assert.doesNotThrow(() => JSON.parse(json));
        });

        it('should include directory, success, and error fields', () => {
            const json = ReportGenerator.generateJson([
                makeResult({ error: 'test error' }),
            ]);
            const parsed = JSON.parse(json);
            assert.strictEqual(parsed[0].directory, '/path/to/my-book');
            assert.strictEqual(parsed[0].success, true);
            assert.strictEqual(parsed[0].error, 'test error');
        });

        it('should spread epubCheckResult fields', () => {
            const json = ReportGenerator.generateJson([
                makeResult({
                    epubCheckResult: makeCheckResult({
                        messages: [{
                            ID: 'RSC-001',
                            severity: 'ERROR',
                            message: 'test',
                            additionalLocations: 0,
                            locations: [],
                        }],
                    }),
                }),
            ]);
            const parsed = JSON.parse(json);
            assert.strictEqual(parsed[0].messages.length, 1);
            assert.strictEqual(parsed[0].messages[0].ID, 'RSC-001');
        });

        it('should not throw when epubCheckResult is undefined', () => {
            const json = ReportGenerator.generateJson([makeResult()]);
            const parsed = JSON.parse(json);
            assert.strictEqual(parsed.length, 1);
        });
    });
});
